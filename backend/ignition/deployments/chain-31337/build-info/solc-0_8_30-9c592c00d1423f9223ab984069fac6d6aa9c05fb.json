{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-9c592c00d1423f9223ab984069fac6d6aa9c05fb",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/Wallegacy.sol": "project/contracts/Wallegacy.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/Wallegacy.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n/*\n  Contract elements should be laid out in the following order:\n    1. Pragma statements\n    2. Import statements\n    3. Events\n    4. Errors\n    5. Interfaces\n    6. Libraries\n    7. Contracts\n\n  Inside each contract, library or interface, use the following order:\n    1. Type declarations\n    2. State variables\n    3. Events\n    4. Errors\n    5. Modifiers\n    6. Functions \n*/\n\ncontract Wallegacy {\n    enum WillStatus {\n        DRAFT, // DRAFT is the gasPayed property is set to false, the Will is mandatory DRAFT\n        SAVED, // SAVED is used when all necessaries elements of the Will are correctly set\n        DONE, // DONE is used when funds has been sent to heirs\n        CANCELLED\n    }\n\n    struct Will {\n        address testator;\n        WillStatus status;\n        bool gasPayed;\n        bool exists; // for getter function\n        Heir heirs;\n    }\n\n    struct Heir {\n        address heirAddress;\n        uint8 percent;\n    }\n\n    mapping(address => Will) private s_testatorToWill; \n\n    // events\n\n    event WillCreated();\n\n    // errors\n\n    error Wallegacy__WillNotFound();\n    error Wallegacy__NoHeirs();\n\n    constructor() {\n    }\n\n    function getWillByTestator(address testatrorAddress) public view returns(Will memory) {\n        Will memory will = s_testatorToWill[testatrorAddress];\n        \n        if (!will.exists) {\n            revert Wallegacy__WillNotFound();\n        }\n\n        return will;\n    }\n\n   /// @dev the status is always set to DRAFT on creation  \n    function createWill(Heir memory heirsParams) public returns(Will memory createdWill)  {\n        if (heirsParams.heirAddress == address(0)) {\n            revert Wallegacy__NoHeirs();\n        }\n\n        s_testatorToWill[msg.sender] = Will({\n            testator: msg.sender,\n            status: WillStatus.DRAFT, \n            gasPayed: false,\n            exists: true,\n            heirs: heirsParams\n        });\n\n        emit WillCreated(); \n\n        return s_testatorToWill[msg.sender];\n    }\n}\n"
      }
    }
  }
}